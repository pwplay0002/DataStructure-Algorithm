// [대학] 잠자는 사자
// 
// 문제
// 한 변의 길이가 n인 정사각형 모양의 초원에서 사자 한 마리가 잠을 자고 있다.하지만 토끼 무리가 사자가 잠을 자는 줄 모르고, 사자의 구역으로 들어와서 놀고 있다.토끼 무리가 시끄럽게 놀자, 사자는 잠에서 깼다.
// 사자는 매우 화가 나서, 주변의 토끼들을 잡아먹기로 결정했다.하지만 사자는 토끼가 이리저리 퍼져있기 때문에 모든 토끼를 사냥할 수 없다는 것을 깨달았다.그래서, 사냥의 우선순위를 두어 사냥을 시작했다.그의 사냥 습관은 아래와 같다.
// 
// ● 사자는 자신의 위치를 중심으로 3x3크기의 영역을 탐색하고, 아래의 그림과 같은 사냥 우선순위를 가지고 있다.즉, 같은 거리에 토끼가 여러마리가 있어서 우선순위가 제일 높은 토끼만 잡아먹는다.
// 1  4 6
// 2  사 7
// 3  5 8
// 
// ● 사자가 토끼의 위치로 이동한 후, 토끼를 잡아 먹는다
// ● 토끼를 잡아먹은 후, 그자리에서 다시 다음으로 사냥할 토끼를 찾는다
// ● 더 이상 잡아먹을 수 있는 토끼가 없을 때, 비로소 사냥을 종료한다.
// ● 사자는 귀찮기 때문에, 초원밖으로 나가지는 않는다.
// ● 토끼는 겁에 질려있기 때문에 움직이지 않는다.
// 사자가 잡아먹을 수 있는 모든 토끼를 잡아먹었을 때, 사자가 먹은 토끼의 마리 수를 알아보자
// 
// 입력
// 초원의 크기 n(1 <= n <= 1000) 이 주어진다
// n줄동안 초원의 상태가 주어진다.각 줄에서 토끼는 1, 사자는 2, 초원은 0이다.
// 
// 출력
// 사자가 잡아먹은 토끼의 마리수를 출력해보자
// 
// 예시1
// 입력
// 4
// 1 0 1 1
// 1 0 1 0
// 0 0 2 1
// 1 0 1 1
// 
// 출력
// 3
// 
// 예시2
// 입력
// 5
// 1 1 1 2 0
// 1 1 1 0 0
// 1 1 0 0 1
// 1 1 1 0 0
// 1 0 0 0 0
// 
// 출력 11
//
//#include <iostream>
//
//using namespace std;
//const int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1 };
//const int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 };
//int a[1004][1004];
//bool visited[1004][1004];
//int n, lx, ly, cnt;
//
//void dfs(int y, int x)
//{
//	if (visited[y][x]) return;
//	visited[y][x] = 1;
//	for(int i = 0; i < 8; i++)
//	{
//		int ny = y + dy[i];
//		int nx = x + dx[i];
//		if(ny < 0 || nx < 0 || ny >= n || nx >= n) continue;
//		if(!visited[ny][nx] && a[ny][nx] == 1)
//		{
//			a[ny][nx] = 0;
//			cnt++;
//			dfs(ny, nx);
//			return;
//		}
//	}
//	return;
//}
//
//int main()
//{
//	ios_base::sync_with_stdio(0); cin.tie(0);
//
//	cin >> n;
//	for(int i = 0; i < n; i++)
//	{
//		for(int j = 0; j < n; j++)
//		{
//			cin >> a[i][j];
//			if(a[i][j] == 2)
//			{
//				ly = i;
//				lx = j;
//			}
//		}
//	}
//	dfs(ly, lx);
//	cout << cnt;
//	return 0;
//}