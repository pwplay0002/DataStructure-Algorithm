//#include <iostream>
//using namespace std;
//
//// ~ : 비트 NOT 연산자 -> 비트를 모두 뒤집는다. 0이면 1, 1이면 0
//// ~x = -(x+1)
//void t1()
//{
//	int n = 15; // 1111
//	int idx = 0;
//	n &= ~(1 << idx); // 1111 & 1110 => 1110
//	cout << "1. idx번째 비트 뒤집기 : " << n << endl;
//}
//
//// ^ 비트 XOR 연산자 -> a^b a의 모든 비트와 b의 모든 비트를 XOR연산한다. 둘이다르면 1, 아니면 0
//void t2()
//{
//	int n = 5; // 1001
//	int idx = 2;
//	n ^= (1 << idx);
//	cout << "2. XOR T2 : " << n << endl;
//}
//
//void t3()
//{
//	int n = 6; // 0110
//	int idx = (n & -n); // 0100 & 1001 => 0000
//	cout << "3. 최하위 켜져 있는 인덱스 T3 : " << idx << endl;
//}
//
//void t4()
//{
//	int n = 4;
//	cout << "4. 크기가 n인 모든 집합의 모든 비트 켜기 T4 : " << (1 << n) - 1 << endl;
//}
//
//// | 비트 OR 연산자 (합연산) -> 하나라도 1이면 1, 아니면 0
//void t5()
//{
//	int n = 8;
//	int idx = 2;
//	n |= (1 << idx); // 100 |= 010  => 110
//	cout << "5. idx번째 불켜기 T5 : " << n << endl;
//}
//
//// & 비트 AND 연산자 -> 두 숫자가 모두 1이라면 1, 아니면 0
//void t6()
//{
//	int n = 15; // 1111
//	int idx = 0;
//	string a = n & (1 << idx) ? "yes" : "no";
//	cout << "6. idx번째 비트가 있는지 확인하기 T6 : " << a << endl;
//}
//
//int main()
//{
//	t1();
//	t2();
//	t3();
//	t4();
//	t5();
//	t6();
//	return 0;
//}
