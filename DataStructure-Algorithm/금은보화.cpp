// 금은보화

// 성태와 현화는 세계 각지에 숨겨진 보물들을 찾아 몇년째 여행중이다.
// 기나긴 여정을 시작한 지 어느덧 1년이 되어 성태와 현화는
// 현재까지 찾은 보물들을 서로 나누어 가지려고 한다.
// 두 사람은 아직 보물들을 현금화하지 않았기 때문에, 보물은 훼손하지 않은채로 최대한
// 공평하게 나누어 가지려고 한다. 성태와 현화는 1년 동안 서로 다른 총 N개의 보물을
// 수집했으며, 각 보물은 고유한 가격을 가지고 있다.
// 단, 가격이 같은 서로 다른 두 개 이상의 보물이 존재할 수 있다.

// 하나의 보물은 두 개 이상으로 쪼개어 가질 수 없다.
// 성태와 현화가 보물들을 나누어 가질 때, 두 사람이 보유한 보물들의 총 가격의 차가
// 최소가 되는 방법과 그러한 방법은 몇 가지가 있는지 계산하는 프로그램을
// 작성해주자. 단, 성태와 현화가 완전히 똑같은 값어치로 보물들을 둘 로 나눌 수
// 없다면, 성태가 조금 더 가지는 것으로 한다.

// 예를 들어서 두 사람이 총 다섯개의 보물을 가지고 있으며, 각 보물의 가격이
// [2,1,8,4,16]와 같다고 하자. 이 경우 A[16], B[1,2,4,8]와 같이 두 명이
// 나누어 가지면 두 사람이 가지는 보물의 총 가격의 차는 1이 된다.
// 그리고 1의 차이가 나도록 조합하는 경우의 수는 위의 예시에서 하나 뿐이다.

// 입력 형식
// 첫 줄에는 두 사람이 가지고 있는 보물의 수를 나타내는 1이상 250이하의
// 자연수 하나가 입력으로 주어진다.
// 이후 총 N개의 보물의 정보가 주어진다. 각 보물의 정보는 한 줄에 하나씩 주어지며,
// 해당 보물의 가격을 나타내는 하나의 정수로 주어진다.
// ● 보물의 가격은 1이상 2,000이하의 자연수다.

// 출력 형식
// 문제의 정답을 두 개의 정수로 표현하며 한 줄에 하나씩 출력한다.
// ● 첫 번째 줄에는 두 사람이 얻을 수 있는 돈의 최소 차이를 출력한다.
// ● 두 번째 줄에는 위의 최소의 차이를 얻을 수 있게 보물들을 분배하는 경우의 수를 출력한다.
//	◎ 단, 경우의 수가 너무 커질 수 있으므로 100만으로 나눈 나머지만을 출력한다.

// 예시 1
// 입력
// 5
// 2
// 1
// 8
// 4
// 16

// 출력
// 1
// 1

// 예시 2
// 입력
// 4
// 1
// 1
// 1
// 1

// 출력
// 0
// 6

// 1 2 3 4
// 2 1 3 4
// 3 2 1 4
// 4 1 2 3
// 1 3 2 4
// 1 4 3 2
// 1 2 4 3
//
// 4 3 2 
// 2 (2)

//#pragma region my solve
//
//#include <iostream>
//using namespace std;
//
//int main()
//{
//	ios_base::sync_with_stdio(0); cin.tie(0);
//	return 0;
//}

#pragma endregion